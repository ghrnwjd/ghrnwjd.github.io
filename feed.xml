<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://ghrnwjd.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ghrnwjd.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-17T09:11:48+00:00</updated><id>https://ghrnwjd.github.io/feed.xml</id><title type="html">hoyoung</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">코딩테스트를 위한 Stream 적응하기</title><link href="https://ghrnwjd.github.io/blog/2024/Stream/" rel="alternate" type="text/html" title="코딩테스트를 위한 Stream 적응하기"/><published>2024-10-16T00:00:00+00:00</published><updated>2024-10-16T00:00:00+00:00</updated><id>https://ghrnwjd.github.io/blog/2024/Stream</id><content type="html" xml:base="https://ghrnwjd.github.io/blog/2024/Stream/"><![CDATA[<p>코딩테스트를 준비하다보니 Stream의 필요성을 느끼게 되어 작성한다.</p> <p>대부분 입력 문자열을 정수로 처리해야하지만 문자열배열로 주어지는 경우가 많았다.</p> <p>예시 문제로 프로그래머스 Level2 호텔 대실 문제의 경우 입력 테스트 케이스가 다음과 같이 입력된다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[["15:00", "17:00"], ["16:40", "18:20"], ["14:20", "15:20"], ["14:10", "19:20"], ["18:20", "21:20"]]
</code></pre></div></div> <p>나의 경우 시간과 분을 <code class="language-plaintext highlighter-rouge">:</code>을 기준으로 나누고 <code class="language-plaintext highlighter-rouge">분</code>으로 치환하고 싶었다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">time</span> <span class="o">=</span> <span class="s">"15:00"</span>

<span class="kt">int</span> <span class="o">[]</span> <span class="n">timeToMinutes</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">time</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">":"</span><span class="o">)).</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
</code></pre></div></div> <p>내가 원하는 값은 “15:00”을 [15, 0]으로 변환하는 것이고 단계별로 살펴보자면 다음과 같다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Step 1: 토큰 단위로 나눈다. 편의상 A라고 치환한다면</span>
<span class="n">time</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">":"</span><span class="o">);</span>
<span class="c1">// result : ["15", "00"]</span>

<span class="c1">// Step 2: Stream 구조로 변환한다.</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">A</span><span class="o">);</span>

<span class="c1">// Step 2-1: 만약 배열구조가 아닌 Collection 타입이라면</span>
<span class="no">A</span><span class="o">.</span><span class="na">stream</span><span class="o">();</span>

<span class="c1">// Step 3-1: Stream -&gt; IntStream으로 변환한다.</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">A</span><span class="o">).</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">);</span>

<span class="c1">// Step 3-2</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">A</span><span class="o">).</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">num</span> <span class="o">-&gt;</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">num</span><span class="o">));</span>

<span class="c1">// IntStream을 Array로 변환한다</span>
<span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="no">A</span><span class="o">).</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">parseInt</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>
</code></pre></div></div> <p>또한 배열안에서의 최대값을 찾고 싶을 때 주로 반복문을 돌렸지만 Stream을 통해 해결할 수 있었다.</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">nums</span> <span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="n">data</span> <span class="o">};</span>

<span class="c1">// 기존의 방식</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="o">}</span>

<span class="c1">// Stream을 사용한 방식</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">nums</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>
</code></pre></div></div> <p>해당 범위의 값을 1씩 늘리고 싶다면</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">count</span> <span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="o">[</span><span class="mi">100</span><span class="o">];</span>

<span class="c1">// 기존의 방식</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
	<span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>
<span class="o">}</span>

<span class="c1">// Stream을 사용한 방식</span>
<span class="nc">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">).</span><span class="na">forEach</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]++);</span>
</code></pre></div></div> <p>IntStream 이외에도 Stream에 다양한 메서드를 활용하면 파이썬과 같이 편하게 코딩할 수 있는 것 같다. Stream을 더 공부해봐야 될 것 같다.</p>]]></content><author><name></name></author><category term="알고리즘"/><summary type="html"><![CDATA[코딩테스트를 준비하다보니 Stream의 필요성을 느끼게 되어 작성한다.]]></summary></entry><entry><title type="html">블록체인이란</title><link href="https://ghrnwjd.github.io/blog/2024/what-is-blockchain/" rel="alternate" type="text/html" title="블록체인이란"/><published>2024-09-13T00:00:00+00:00</published><updated>2024-09-13T00:00:00+00:00</updated><id>https://ghrnwjd.github.io/blog/2024/what-is-blockchain</id><content type="html" xml:base="https://ghrnwjd.github.io/blog/2024/what-is-blockchain/"><![CDATA[<p>블록체인은 <code class="language-plaintext highlighter-rouge">비즈니스 네트워크에서 거래를 기록하고 자산을 추적하는 프로세스를 용이하게 하는 변경 불가능한 공유원장</code>이라고 정의되어 있다.</p> <ol> <li>네트워크에서 거래를 기록 <ol> <li>블록체인의 작동방식에 따라 거래 기록은 블록으로 온라인에 등록되고 네트워크를 통해 모든 참여자에게 전달된다.</li> </ol> </li> <li>자산을 추적 <ol> <li>블록 또는 체인을 통해 자산의 이동 경로를 추적할 수 있다.</li> </ol> </li> <li>변경 불가능한 <ol> <li>거래를 진행함에 있어 네트워크 안에 모든 참여가자가 거래를 유효하다는 것을 승인해야 거래가 진행되며 승인시 블록을 체인에 추가하여 변경 또는 지울 수 없는 투명한 레코드를 제공한다.</li> </ol> </li> <li>공유원장 <ol> <li>공유원장 또는 분산원장이라고 불리며 데이터는 중앙 서버가 아닌 여러 기관 및 사용자에게 분산되어 저장되어 있다.</li> </ol> </li> </ol> <h3 id="블록체인-핵심-요소">블록체인 핵심 요소</h3> <ol> <li>분산 원장 기술</li> <li>변경 불가능 기록</li> <li>스마트 컨트랙트 <ol> <li>특정 계약의 내용을 구현한 컴퓨터 코드로 계약의 조건을 만족시킬 시 모든 노드에서 무조건적으로 실행되는 코드, 무조건 실행되기에 unstoppable contract로도 불린다.</li> </ol> </li> </ol> <h3 id="블록체인-작동-방식">블록체인 작동 방식</h3> <p>분산 원장 기술은 중앙 서버가 없기 때문에 개인 간 <code class="language-plaintext highlighter-rouge">P2P 알고리즘</code>을 통해 거래가 이루어진다. 데이터는 네트워크 내 여러 노드에 분산되어 저장되고 원장이 업데이트 될때마다 타임스탬프와 고유 암호화 서명이 부여되며 동기화된다. 블록체인은 거래가 유효하며 기록되기 위해 네트워크 내 노드들은 <code class="language-plaintext highlighter-rouge">합의 알고리즘</code>을 사용하여 합의한다. 크게 작업 증명과 지분 증명 메커니즘이 사용된다. 승인된 트랜잭션은 <code class="language-plaintext highlighter-rouge">블록</code>으로 기록되며 각 블록은 이전, 이후 블록과 연결되어 체인을 형성한다. 이전과 이후 블록과 연결되고, 다른 블록이 중간에 삽입되는 것을 막아 트랜잭션 간 시간, 순서의 일관성을 지킬 수 있다.</p> <h4 id="합의-알고리즘">합의 알고리즘</h4> <ul> <li>PoW(Proof of Work) <ul> <li>작업 증명 방식은 이중 지불을 방지하는 메커니즘이다. 이중 지불이란 동일한 자금이 여러번 사용되는 것을 말한다.</li> <li><a href="https://academy.gopax.co.kr/cobojareul-wihan-biteukoin-raiteuning-neteuweokeu-seolmyeong/">여기</a>에서 확인 할 수 있다.</li> </ul> </li> <li>PoS(Proof of Stake) <ul> <li>지분 증명 방식은 디지털 자산을 많이 가질수록 블록에 기록할 권한을 더 많이 부여하는 증명방식으로 블록이 생성되면 지분에 대한 이자로 보상을 받아 악용을 막는다.</li> </ul> </li> </ul> <p>더 알아봐야 할 용어 : <code class="language-plaintext highlighter-rouge">51% 공격</code></p> <h2 id="블록체인이란-무엇인가요을-참고하였습니다"><a href="https://www.ibm.com/kr-ko/topics/blockchain">블록체인이란 무엇인가요?</a>을 참고하였습니다.</h2>]]></content><author><name></name></author><category term="블록체인"/><summary type="html"><![CDATA[블록체인은 비즈니스 네트워크에서 거래를 기록하고 자산을 추적하는 프로세스를 용이하게 하는 변경 불가능한 공유원장이라고 정의되어 있다.]]></summary></entry><entry><title type="html">솔리디티 기본 문법</title><link href="https://ghrnwjd.github.io/blog/2024/solidity-basic/" rel="alternate" type="text/html" title="솔리디티 기본 문법"/><published>2024-09-09T00:00:00+00:00</published><updated>2024-09-09T00:00:00+00:00</updated><id>https://ghrnwjd.github.io/blog/2024/solidity-basic</id><content type="html" xml:base="https://ghrnwjd.github.io/blog/2024/solidity-basic/"><![CDATA[<p><strong>컨트랙트의 기본 구조는 <code class="language-plaintext highlighter-rouge">라이센스 명시</code>, <code class="language-plaintext highlighter-rouge">컴파일러 명시</code>, <code class="language-plaintext highlighter-rouge">컨트랙트 작성</code>으로 분류할 수 있다.</strong></p> <h3 id="라이센스-명시">라이센스 명시</h3> <p>스마트 컨트랙트에 대한 신뢰도를 높이고 저작권 문제 해결을 위해 <code class="language-plaintext highlighter-rouge">SPDX 라이센스</code>를 사용</p> <ul> <li>ver 0.68 이후 미 기재시 에러가 발생한다.</li> <li>SPDX 리스트에 있지 않아도 컴파일러는 알아채지 못하지만 꼭 명시는 해야 한다. <ul> <li>SPDX-License-Identifier: UNLICENSED &gt; 가능</li> <li>공란 &gt; 불가능</li> </ul> </li> </ul> <h3 id="컴파일러-버전-명시">컴파일러 버전 명시</h3> <p>솔리디티는 이더리움 가상 머신(EVM) 위에서 스마트 컨트랙트 개발을 위한 프로그래밍 언어이므로 작성 코드를 바이너리 코드로 변환하기 위해 솔리디티 컴파일러인 solc를 사용해야 한다. 컴파일러 버전에 따라 문법의 차이가 있을 수 있기에 <code class="language-plaintext highlighter-rouge">pragma</code> 키워드를 사용하여 solc의 버전을 명시해준다.</p> <p>예시로 <code class="language-plaintext highlighter-rouge">pragma solidity ^0.8.0</code>은 0.8.0 이상의 컴파일러를 사용하겠다라는 뜻이다.</p> <h3 id="컨트랙트-선언-및-정의">컨트랙트 선언 및 정의</h3> <p><code class="language-plaintext highlighter-rouge">contract</code> 라는 키워드를 입력하여 컨트랙트 명과 코드를 작성한다. 컨트랙트 명명 규칙은 단어의 구분마다 첫 글자를 대문자로 시작하는 <code class="language-plaintext highlighter-rouge">PascalCase</code>를 사용한다.</p> <p><strong>솔리디티 샘플 코드</strong></p> <pre><code class="language-sol">// SPDX-License-Identifier: GPL-3.0 // 라이센스 명시
pragma solidity &gt;=0.8.2 &lt;0.9.0; // 컴파일러 명시

contract Storage { // 컨트랙트 선언 및 정의
	uint256 number;

	/**
	* @dev Store value in variable
	* @param num value to store
	*/
	function store(uint256 num) public {
		number = num;
	}

	/**
	* @dev Return value
	* @return value of 'number'
	*/
	function retrieve() public view returns (uint256){
		return number;
	}
}
</code></pre> <p>해당 포스팅은 <a href="https://www.youtube.com/watch?v=8fEwzGQausQ&amp;list=PLzUgt9aUfvBTFjNTOP4BUGSj5yNtDgBZ_&amp;index=11">스마트 컨트랙트 실전</a> 영상을 참고하여 작성한 포스팅입니다.</p>]]></content><author><name></name></author><category term="블록체인"/><summary type="html"><![CDATA[컨트랙트의 기본 구조는 라이센스 명시, 컴파일러 명시, 컨트랙트 작성으로 분류할 수 있다.]]></summary></entry><entry><title type="html">al-folio 적용</title><link href="https://ghrnwjd.github.io/blog/2024/%EA%B9%83-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%81%EC%9A%A9/" rel="alternate" type="text/html" title="al-folio 적용"/><published>2024-09-08T00:00:00+00:00</published><updated>2024-09-08T00:00:00+00:00</updated><id>https://ghrnwjd.github.io/blog/2024/%EA%B9%83-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%81%EC%9A%A9</id><content type="html" xml:base="https://ghrnwjd.github.io/blog/2024/%EA%B9%83-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%A0%81%EC%9A%A9/"><![CDATA[<p>github.io를 시작하며 일어난 오류 정리</p> <h3 id="1-al-folio-clone">1. al-folio clone</h3> <p><a href="https://github.com/alshedivat/al-folio">al-folio</a>를 참고한다.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/alshedivat/al-folio
</code></pre></div></div> <h3 id="2-git-repo-설정">2. git repo 설정</h3> <p>설명에 나와있는대로 <code class="language-plaintext highlighter-rouge">Settings -&gt; Actions -&gt; General -&gt; Workflow permissions and give Read and write permissions to GitHub Actions.</code> 을 적용해준다.</p> <p>나중에 배포하는 과정에서 아래와 같은 에러가 발생할 수 있다.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Liquid Exception: Liquid syntax error <span class="o">(</span>line 42<span class="o">)</span>: Unknown tag <span class="s1">'toc'</span> <span class="k">in</span> /_layouts/post.html
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">gh-pages</code>라는 브랜치를 만들어 <code class="language-plaintext highlighter-rouge">Settings -&gt; Pages -&gt; Build and deployment</code> 에서 기본 브랜치를 <code class="language-plaintext highlighter-rouge">gh-pages</code>로 설정해준다.</p> <h3 id="3-customizing">3. customizing</h3> <p>나에게 맞게 _config.yml을 적용하고 publication, cv, teaching, profiles nav는 나에게 필요없었기 때문에 <code class="language-plaintext highlighter-rouge">_pages/파일.md</code>에서 nav를 false로 바꾸어 보이지 않게 설정하였다.</p> <h3 id="4-install">4. install</h3> <p>docker를 설치하고, 해당 폴더로 이동한 뒤 다음 명령어를 실행해준다.</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose pull
docker compose up
</code></pre></div></div> <h3 id="5-deploy">5. deploy</h3> <p>깃을 통해 레포에 푸시한 뒤 <code class="language-plaintext highlighter-rouge">Action</code> 탭에서 제대로 Deploy가 되는지 확인한다. 적용된 깃허브 블로그는 **<a href="https://ghrnwjd.github.io">여기</a>에서 확인할 수 있다.</p>]]></content><author><name></name></author><category term="etc"/><summary type="html"><![CDATA[github.io를 시작하며 일어난 오류 정리]]></summary></entry><entry><title type="html">블로그 이전</title><link href="https://ghrnwjd.github.io/blog/2024/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9D%B4%EC%A0%84/" rel="alternate" type="text/html" title="블로그 이전"/><published>2024-09-07T00:00:00+00:00</published><updated>2024-09-07T00:00:00+00:00</updated><id>https://ghrnwjd.github.io/blog/2024/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9D%B4%EC%A0%84</id><content type="html" xml:base="https://ghrnwjd.github.io/blog/2024/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%9D%B4%EC%A0%84/"><![CDATA[<p>2024년 9월부로 깃허브 블로그로 작성하려고 합니다.</p> <p>이전 포스팅은 <strong><a href="https://ghrnwjd.tistory.com">Tistory</a></strong> 을 참고 부탁드립니다.</p>]]></content><author><name></name></author><category term="sample-posts"/><summary type="html"><![CDATA[2024년 9월부로 깃허브 블로그로 작성하려고 합니다.]]></summary></entry></feed>